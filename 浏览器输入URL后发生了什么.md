##在浏览器输入URL后发生了一下事情
1、URL解析：识别协议类型、域名地址、资源路径、问号参数等
2、缓存检查：(静态资源缓存)
  ~第一次发送请求没有任何缓存直接请求服务器，在请求服务器之前进行域名(DNS)解析，解析后进行网络请求，服务器在返回数据的同时会在header上添加cache-control(http1.1)/expires(http1.0)字段标识进行强缓存(内存缓存和硬盘缓存)
  ~刷新页面进行第二次请求会进行缓存检查，首先进行强缓存检查，先检查内存中是否有缓存，没有就检查硬盘中是否有缓存，有并且有效就code200返回缓存数据。
  ~如果没有强缓存或者强缓存失效了，进行协商缓存检查。在请求数据时，header中携带If-Modifid-Since(http1.0)/If-None-Match(http1.1)字段到服务器，服务器根据这两个字段对比Last-Modified(http1.0)/Etag(http1.1)，如果无效就进行数据返回code200。有效就返回304状态。
  ~协商缓存：不管缓存是否有效都要请求服务器，由服务器进行缓存是否有效对比。
  **html资源一般不做缓存，html中的引用的js、css、图片等资源内容更新后，都会重新更新文件名称等，已保证获取最新的资源
  **webpack的打包时的文件名+hash值
3、域名(DNS)解析:
  ~根据URL中的域名地址从浏览器缓存->本地Hosts文件->本地DNS缓存->本地DNS服务器进行递归查询
  ~如果经过上边的递归查询还是没有找到，就从根域名服务器->顶级域名服务器->权威域名服务器进行迭代查询域名
  ~DNS解析性能优化：DNS预获取，在header中使用link rel='dns-prefetch' 进行预获取
4、TCP建立连接
  ~TCP三次握手
   1、第一次握手：客户端发送SYN=1，seq=x到服务器，告诉服务器要建立链接通道
   2、第二次握手：服务器收到客户端请求后，发送ACK=1，ack=x+1，SYN=1，seq=y到客户端，告诉客户端收到请求，可以建立链接通道
   3、第三次握手：客户端回应服务器发送ACK=1，ack=y+1，seq=x+1收到消息，并准备开始发送数据请求。
  ~SYN：建立新连接请求
  ~ACK：确实序号有效
  ~FIN：释放连接
  ~seq：序号
  ~ack：确认序号，ack=seq+1
5、发送请求，获取html、js、css文件进行页面渲染
  ~将HTML内容转成DOM树结构
  ~将CSS样式转成CSS样式结构
  ~使用DOM树和CSS样式构建成render树结构
  ~将render树结构渲染显示，展示给用户
6、TCP四次挥手，关闭连接
  ~第一次挥手：客户端发送FIN=1，seq=x到服务器端
  ~第二次挥手：服务器端发送ACK=1，ack=x+1到客户端，告诉客户端收到关闭连接的请求了。服务端准备最后一次的数据发送
  ~第三次挥手：服务器端发送FIN=1，seq=y到客户端告诉客户端可以断开连接了
  ~第四次挥手：客户端发送ACK=1，ack=y+1到服务器端，告诉服务器收到了，并关闭连接。服务器收到消息后也关闭连接


###注意：
http1.0，TCP连接是一个请求建立一个连接通道，如果手动设置了connection:keep-alive，就保持连接通道长期存在(长连接)
http1.1默认使用长连接，无需手动设置connection:keep-alive
    1.x版本请求都是串行的，需要等着上一个请求回应以后，才能进行下一个请求。同一域名下的请求有一定数量限制(4个)
http2.0 采用多路复用进行请求并行


##http1.x和http2.0的区别
  ~http1.x多个资源请求需要建立多个连接，http2.0同一个连接能发送多个资源请求
  ~http1.x的请求头是纯文本，https是二进制；http2.0采用HPACK压缩头部，减少报文大小，对固定的报文，采用静态索引表的方式维护头部键值对
  ~http2.0增加了server push功能，服务器可以主动把客户端需要的资源推送到客户端


